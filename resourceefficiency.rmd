---
title: "resourceefficiency.rmd"
author: "Adrian Leip"
date: "Thursday, January 05, 2017"
output: html_document
---

Script calculating resource efficiency according to Heijungs and Suh (2002).

```{r,echo=FALSE}
source("resourceefficiency.r")
doheader()
supplychain<-supplychainsimple()
processes<-supplychain[[1]]
nproc<-supplychain[[2]]
products<-supplychain[[3]]
nprod<-supplychain[[4]]
resources<-supplychain[[5]]
losses<-supplychain[[6]]
nenv<-supplychain[[7]]
recycling<-supplychain[[8]]

waste<-c()
goods<-products[!products%in% waste]
interventions<-c(resources,losses)
```


# Problem definition
## Processes
We assess a three-process life cycle:

```{r, echo=FALSE}
for(i in 1:nproc) cat(i,processes[i],"\n")
```

All flows are expressed in kg of nitrogen.

### Feed production

- _Inputs_ to feed production are mineral fertilizer, crop residues, manure, and processing by-products.
- _Outputs_ to feed production are the feed (that is used in the livestock production stage/process), crop residues (recycled into the crop production process as a closed loop) and a crop-co-product which is exported from the system.
- Additionally, feed production generates _losses to the environment_.

### Livestock production
- _Inputs_ to the livestock production system is exclusively the feed produced in the crop productino process
- _Outputs_ are the livestock product which goes to the processing stage. A co-product is exported. Manure is used in the crop production process
- Additionally, _losses to the environment_ occur.

### Food production
- Only _input_ is the livestock product
- _Outputs_ are the main food product and a co-product which is recycled back to the crop production process
- Additionally, _losses to the environment_ occur.

## Economic flows
The following economic flows are differentiated:
```{r,echo=FALSE}
for(i in 1:9) cat(i,products[i],"\n")
```

In the default desing of the system, all residues are recycled in the system and none is wasted.

```{r, echo=FALSE}
if(length(waste)>0)for(i in 1:length(goods)) cat(i,goods[i],"\n")
```

## Environmental flows
We regard all environmental losses here independently of their nature.
Therefore, there is only one environmental flow:

```{r,echo=FALSE}
for(i in 1:length(interventions)) cat(i,interventions[i],"\n")

```

# Data input
## Process vectors

The *Technology matrix _A_* gives the economic flows.
It has `r length(products)` rows and `r length(processes)` columns.

The *Intervention matrix _B_* gives the environmental flows.

The *Process matrix _P_* is the combination of A and B.Each column represents one *process vector* made from the technology vector t_i and the intervention vector i_i

```{r}
egsupply<-exampleaimable(nproc,nprod,nenv)
supplymat<-processmatrix(egsupply,supplychain)

A<-supplymat[[1]]
B<-supplymat[[2]]
P<-supplymat[[3]]
f<-egsupply[[3]]
```


##Allocation factors
Allocation factors - if used - are required for all products which are produced in the process.

For wastes == 0, for goods > 0.

## Demand vector
There is demand only for food. Therefore, all for all ecnomic flows, which are not completely re-absorbed in the process, an additional process must be defined which consumes the product.


# Calculations

## Scaling vector
The scaling vector is obtained by multiplying the inverse of the technology matrix with the demand vector f
```{r,echo=FALSE}
scaling<-scaling(A,f)
s<-scaling[[1]]
P<-scaling[[2]]
print("Scaling factors:")
for(i in 1:nproc) cat("Process:",i," (",processes[i],") - ",s[i],"\n")
cat("Demand vector:\n",f,"\n")
```

## Fill recycling flows
Assumptions:

1. Each recycling flow is consumed by one process only (i.e. food processing residue is either used as feed or as fertilizer. If it is used for both purposes, then they should be two recycling flows defined.)
2. All recycling flows can be absorbed. If more is produced then the surplus must be shifted to 'export' or 'waste' (depending..) but this is not programmed yet.
3. The system draws on exactly ONE resource.If thereare more than one resource, then there must be rules how to account for accounting, but this has not been programmed yet.

```{r}
P<-fillrecycling(recycling,P,nproc,nprod)
print(P)

```

## Analysis of type of flows

- *Chainflows* are those which are produced in one process and consumed in another process

```{r,echo=FALSE}
flowanaly<-flowanalysis(P,nprod,recycling,goods,resources)
chainflows<-flowanaly[[1]]
origin<-flowanaly[[2]]
target<-flowanaly[[3]]
exportflows<-flowanaly[[4]]
sumgoods<-flowanaly[[5]]
suminputs<-flowanaly[[6]]
nue<-flowanaly[[7]]
```
## Nitrogen Use Efficiency for each process
NUE is calculated from the ratio of goods produced in a process to the sum of inputs. Here, NUE is calculated as a characteristicum of the process itself, thus no differentiation is made between different goods.

```{r,echo=FALSE}
cat("Sum of inputs per process\n")
print(suminputs)
cat("Sum of goods produced per process\n")
print(sumgoods)
cat("NUE per process\n")
print(nue)
```
## Resource use per process
Total resource use is the sum of all inputs (goods and resources) which are not recycled in the process.

For this purpose a matrix need to be generates with rows/columns representing the processes. Each cell is the total net production/consumption of goods. Thereby products are aggregated according to their origin into 'feed products', 'livestock products', 'food products'.


According to Suh et al. (2011) each cell is obtained from

v - u - m + s

V: Production of product in process
u: Use of product in process
m: Import of product into process
s: Stock change [considered as good]

This is achieved by filtering for each product the flows originating from the corresponding process and summing by process:

The inverse of this matrix is multiplied with the resource vector

Finally, the resource-need vector for the processes is obtained according to equation (4) in Suh et a., (2011)

According to Uwizeye et al. (2016), the life-cycle NUE is obtained as inverse of the resource-intensity of the last process

```{r,echo=FALSE}
nutflow<-nutflowanalysi(P,nproc,nprod,origin,resources)
V<-nutflow[[1]]
r<-nutflow[[2]]
rintensity<-nutflow[[3]]
lcanue<-nutflow[[4]]
print(V)
print(r)
print(rintensity)
print(lcanue)
```
# Defining Allocation factors

## Allocation by share of nutrient flow from 'goods'
```{r}
lambda<-allocationbyflow(P,goods,origin)
lambda<-allocationbyvalue1(nproc,nprod)
lambdamain<-lambda[[2]]
lambda<-lambda[[1]]
print(lambda)
```

## Steps to account for allocation in the matrix-approach

1. Multiply each good with its allocation factor
2. The inputs from other processec receive the values of the respective out flows
3. Generate new 'V' vector. The diagonal is the total of net goods per process (same as before). The non-diagonal cells contain the flows between processes. The sum of the rows gives the amount of goods exported (thus total produced minus recycled back or forwarded to following processes).
4. Apply formula as before.

```{r}
lambda<-allocationbyvalue1(nproc,nprod)
lambda[1,]+colSums(lambda*(target==1&origin!=1))
lam4<-matrix(0,ncol=nproc,nrow=nproc)
lam4[1:nproc,1:nproc]<-1*diag(3)
for(i in 1:nproc){
    sv<-(nproc+1):nprod
    #chainlambda<-sapply(1:nproc,function(x) Reduce("*",colSums(lambda[1:nproc,1:nproc])[1:x]))
    lam4[i,]<-lam4[i,]+colSums(lambda[sv,]*(target[sv]==i&origin[sv]!=i))
    print(i)
    print(lam4)
    if(i>1)lam4[i,]<-lam4[i,]+lam4[i-1,]
    lam4[i,]<-lam4[i,]*lambda[i,i]
    print(lam4[i,])
    print(lam4)
}


dirburden<-sapply(1:nproc,function(j) sapply(1:(nprod),function(i) -lambda[i,j]*as.vector(P[nprod+2,j])))

# Calculate the embedded burden in recycling flows
# This formula calculates how much burden of a chainflow needs to be added to the target process
recburden<-colSums(sapply(1:nproc,function(x) rowSums(dirburden*chainflows*(target==x))))

embburden<-sapply(1:nproc,function(j) sapply(1:(nprod),function(i) lambda[i,j]*recburden[j]))

totburden<-dirburden+embburden
totburden[chainflows,]<-0

totburden2<-totburden
totburden2[,1]<-totburden[,1]
totburden2[,2]<-totburden[,2]+totburden2[1,1]*lambdamain[,2]
totburden2[,3]<-totburden[,3]+totburden2[2,2]*lambdamain[,3]
totburden2[1,1]<-0
totburden2[2,2]<-0

#New approach
lam3<-matrix(0,ncol=nproc,nrow=nproc)
# Let emissions flow back; don't use matrix approach because there is no 'flow of emissions' 
# But assign embodied emissions in recycled biomass back to the stage it is used
lam3[1,]<-c(lam2r[1,1],lam2r[8,2],lam2r[9,3])
lam3[2,]<-c(lam2r[1,1],lam2r[2,2]+lam2r[8,2],lam2r[9,3])
lam3[3,]<-c(lam2r[1,1],lam2r[2,2]+lam2r[8,2],lam2r[3,3]+lam2r[9,3])
#feintensity<-lam3%*%e
#ffootprints<-feintensity/colSums(P[1:3,1:3]*diag(3))

```

# Distribution of emissions according to allocation factors

One flow-matrix is generated per environmental flow, both resources and losses.

```{r}
envflows<-lapply(1:nenv,function(x) sapply(1:nproc,function(j) sapply(1:(nprod+1),function(i) (if(i>nprod){1}else{-lambda[i,j]})*as.vector(P[nprod+x,j]))))

e<-as.vector(as.matrix(P[11,]))
eintensity<-t(e)%*%ginv(V)
rintensity<-t(r)%*%ginv(V)
rintensity2<-t(r)%*%ginv(t(V))
print(eintensity)
print(rintensity)

# For Footprint calculation only the core matrix is needed
# giving the main flows connecting the total food production system
corematrix<-P[1:nproc,1:nproc]*diag(3)

burden<-t(as.matrix(P[(nprod+1):(nprod+nenv),]))
# Vectorize the allocation factors [for the burden in question if differentiated]...
corealloc<-apply(lambda[1:nproc,1:nproc],1,sum,na.rm=T)
#... and calculate the product of factors along the chain
# The result is a vector indicating which share of a flow from each process ends up in the final product
# This is in this example simple because the system is linear
corealloc<-sapply(1:nproc,function(x) Reduce("*",corealloc[x:nproc]))
# The footprint by process gives the total burden that is to be allocated to the final demanded products, differentiation by the process that generates it.
footprintbyprocess<-burden*corealloc #/sum(f)
#
footprints<-apply(footprintbyprocess,2,sum)


```


# Results
Final Process matrix P: 
```{r, echo=FALSE}
print(P)
```

Scaling from 'original' dataset:
```{r, echo=FALSE}
print(s)
```

Nitrogen use efficiency per process:

- `r processes[1]`: `r round(nue[1],3)`
- `r processes[2]`: `r round(nue[2],3)`
- `r processes[3]`: `r round(nue[3],3)`


Resource intensities:

- `r processes[1]`: `r round(rintensity[1],3)`
- `r processes[2]`: `r round(rintensity[2],3)`
- `r processes[3]`: `r round(rintensity[3],3)`

Full-life cycle NUE is thus: `r round(100*lcanue,1)`%.

# Discussion
## Resource intensity
The resource intensity gives the quantity of resources required to sustain the process chain to produce the main desired product *plus* all other goods that are produced in the process chain.

Each process has a characteristic resource intensity for each of the *total goods* that is generic for all goods produced in the process chain. 

For example, process 1 has a resource intensity of `r round(rintensity[1],2)` which is obtained from the fact that it produces `r V[1,1]` of goods (sum of feed and exported goods). At the same time, it consumes `r V[2,1]` of goods produced in the second process and `r V[3,1]` of goods produced in the third process which are produced with the intensity `r round(rintensity[2],2)` and `r round(rintensity[3],2)`. Thus `r V[1,1]` * `r round(rintensity[1],2)` + `r V[2,1]` * `r round(rintensity[2],2)` + `r V[3,1]` * `r round(rintensity[3],2)` = `r round(V[1,1]*rintensity[1],2)` + `r round(V[2,1]*rintensity[2],2)` + `r round(V[3,1]*rintensity[3],2)` = `r round(V[1,1]*rintensity[1]+V[2,1]*rintensity[2]+V[3,1]*rintensity[3],2)`. A product that 'comes out' of the first process has the resource efficiency `r round(1/rintensity[1],3)`, a product that results from the second process (thus goes through the first two processes) has the resource efficiency `r round(1/rintensity[2],3)` and a process that goes through all three processes is produced with the efficency `r round(1/rintensity[3],3)`

Overall, the process chain generates `r sum(apply(V,1,sum))` units of goods with a total input of `r sumgoods[1]`, thus giving an overall efficiency of `r sum(apply(V,1,sum))/sumgoods[1]`.


